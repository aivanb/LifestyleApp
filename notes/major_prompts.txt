==== Inital Prompt ====
Create the initial guidelines and project skeleton for a fullstack application using Django, Node.js, React, MySQL, and the OpenAI API.
These are the things that should be initially added:
- Initialize a database using MySQL. You can find the schema in notes/database_structure.md. Match this schema exactly. 
- JWT login and authentication requests for current users. Provide endpoints for user registration, login, and token validation.
- Add simple OpenAI API request handling (basic endpoint to send a prompt and return a response).

Constraints:
- Build a foundation/skeleton, not a polished app.
- The codebase should be structured for future expansion by other developers or agents.
- Focus on clean separation of concerns (frontend, backend, database, integrations).
- Follow your own style and structural rules.


==== Update MySQL tables ====
Repeat your rules back to me so I can make sure you are following them correctly. 

Do the following in the specificed order. 
- 1. update the database setup scripts to include these updates:
-- add a rest_time field to the workout_log
-- add a make_public field to the foods and workouts tables
-- remove the day_worked fields in the muscle_log tables
-- add the created_at field to the muscle_log table
-- change the field id to muscle_log_id in muscle_log table
- 2. Add the following tables to the database setup scripts
--
#### **splits**
The different splits that a user has
```sql
- splits_id (PK): Auto-incrementing ID
- user_id (FK): users.user_id
- split_name: The name of the split
- start_date: When the user is starting the split
- created_at: Timestamp when created
```
#### **split_days**
```sql
- split_days_id (PK): Auto-incrementing ID
- splits_id (FK): splits.splits_id
- day_name: the name of the split day
- day_order: the local order of this split day, stored as a number
```
#### **split_day_targets**
```sql
- split_day_id (FK): split_days.split_days_id
- muscle_id (FK): muscles.muscles_id
- target_activation: the target activation
```
--
- 3. Update the database_structure.md so that it matches the database structure exactly. Maintain the current formatting of database_structure.md
- 4. Provide me clear instructions on how I can update the database to reflect the changes made


==== Database Fill ====
Repeat your rules back to me so I can make sure you are following them correctly. 
Create scripts to fill in the database with the following rules. Many tables already have prefilled data. Do not rewrite code for these tables. 
These tables should be prefilled whenever the database it setup. It is neccesary data for the website to run properly. 
- access_levels
- activity_levels
- auth_permission
- django_content_type
- muscles
- units

These tables are not required to be prefilled in order to run the website. However you should create dummy data for verification and testing purposes
This dummy data should be portraying two differnt users, each with about 6 months of recorded data. Make the data realistic based on the field names. 
Provide the credintials for the two users. 
- api_usage_log
- auth_group
- auth_group_permissions
- body_measurement_log
- cardio_log
- error_log
- food_log
- foods
- health_metrics_log
- meals
- meals_foods
- muscles_log
- sleep_log
- steps_log
- user_goal
- users
- users_groups
- user_user_permissions
- water_log
- weight_log
- workout_log
- workout_muscle
- workouts
- splits
- split_days
- split_day_targets

These tables are not required to be prefilled. They should not be given dummy data. 
- django_admin_log
- django_migrations
- django_session

Create a clear separation between required data and non required dummy data. At any point it should be possible to easily reset the database, resetting 
the required tables to inital data, and removing all non required data. 
Add useful functions within database setup files that can: reset the database and prefill the database with dummy data


==== Database viewer ====
Repeat your rules back to me so I can make sure you are following them correctly. 
Create an interface for viewing the database data from the frontend. Include filtering, sorting, and searching capabilites. 
Scripts fetching data from the database through the backend should become a standard foundation for all future systems. 
Methods created to access data should be comprehensive, abstract, and modular enough to be viable for many different use cases across many different systems. 
The docuementation should written up so it is clear that future systems will use these scripts for accessing the database. 
The following features should be enforced in your implementation
- authentication should be handled at the beginning of this process. 
- authenticate different access levels accessing the different information. Find the access levels from the currently logged in user. 
-- admin: able to view all tables and every users information
-- user: cannot see internal tables (auth permissions, django, ect)
-- user: only able to view data marked with their users id or make_public=true (not all tables have users_id and/or make_public fields)
-- guests can see what users can see except cannot view tables marked with make_public=true
- proper type checking for all data
- handle empty, null, and corrupt data with exepction checking
- proper logging for access events and issues. 
- security against attacks including parameterization, sanitization, enforced authentication, ect

==== Visual Improvement ====
Repeat your rules back to me so I can make sure you are following them correctly. 
Create a VISUAL_FORMATTING.md that can be referenced by future developers to maintain a consistent visual design. 
Update the developer documentation to reference the VISUAL_FORMATTING.md
Create both a pc and mobile view for the app. Provide multiple color themes for the app.
Change the formatting, color scheme, text style, typography, quality, UI elements, and layout to match a more minimalistic and modern design.
Visual design rules
- Monotone colors for general purposes UI elements with colorful highlightst for important elements
- High contrast between background and foreground elements
- Wide variety of shapes used for UI elements
- Layering of visual UI elements while maintaining clarity.
- Wide variety of user feedback on almost all interactable UI elements
Specific UI element rules
- Monotone icons for buttons and labels. Use both icons paried with text and only icons
- Rounded edges for tabs, buttons, and input areas
- Smooth transitioning (slides, tab openings, pop-ups, ect). Create spline curves rather than linear openings
- Use Roboto Mono as the main font

Create a new file for any desired images. This file will contain the image path along with copyright information. 
If you add an image to the UI fill in the image file with the filepath, description, size, color scheme, ect, for all images.
Prioritize functionality and clarity override decorative or unique design. and maintain accessibility and readability at all times.


==== Food Tracker | No Generative Model ===
Repeat your rules back to me so I can make sure you are following them correctly. 
Implement a food logging system in the existing codebase. Maintain modular, abstract, and reusable design. Do not add features beyond what is described.
Requirements:
Food Creator
- Users can create a new food entry with all relevant data.
- Users can mark a food as public, allowing all users to view it.
- Users can customize servings.
- Provide a preview of the basic macros (calories, protein, carbs, fats).
- Users can optionally create and log the food simultaneously.
Meal Creator
- Users can create a meal consisting of multiple foods.
- Servings for each food can be customized.
- Provide a preview of the meal’s basic macros.
- Users can optionally create and log the meal simultaneously.
Food Log
- Users can view and search foods they own or public foods.
- Filtering options: keyword search, macro range, or by default, most recently logged foods.
- Display a list of recently logged foods with basic macros.
- Users can delete foods from the log.


=== Food Logger | With OpenAI ===
Repeat your rules so that it can be ensured you are following them correctly. 
Create a chatbot that logs foods using the OpenAI API and integrates with the existing database tables and logic. The chatbot must accept both text and voice input.

VOICE INPUT:
- Use Vosk offline speech recognition (vosk-model-small-en-us-0.15).
- Implement a record button to start recording and display a live timer (in seconds).
- Automatically stop recording after one minute or when the stop button is pressed.
- Display the transcribed text in an editable input field.
- Users can edit this text before manually submitting it to the food parsing system.

TEXT INPUT:
- Allow users to type text directly.
- Include a Send button to submit text to the food parsing system.
- Include a Create a Meal button to group multiple foods into one meal.
- Display recent chatbot interactions in a small window showing user inputs and system responses.

DATABASE VALIDATION:
- Before writing queries, check the database setup scripts to confirm the schema for each table.
- Use the correct table names, fields, and relations as defined in the setup scripts.

FOOD PARSING SYSTEM:
1. Input: a string containing one or more foods.
2. Send the string to the OpenAI API to identify all foods and provide metadata.
   - The API must return a JSON list of dictionaries.
   - Each dictionary contains a "name" and associated "metadata”
3. For each food returned:
   a. Check if it exists in the user's meals table.
      - If found, ignore metadata and log the meal.
   b. If not found in meals, check the foods table.
      - If found and no metadata provided: log the food.
      - If found and metadata provided do not match: log it and create a duplicate entry with a duplicate flag.
      - If found and metadata match: log it normally.
   c. If the food is not found in either table:
      - Use the OpenAI API to generate missing metadata.
      - If no metadata provided: generate all metadata.
      - If partial metadata provided: keep existing and generate missing metadata.
      - If all metadata provided: skip generation.
      - Insert the new food into the foods table and log it.
4. If the Create a Meal button is selected:
      - Create a new meal entry containing all foods from the current input.
      - If existing meals are referenced, include their foods in the new meal.

MANUAL SYSTEM
- Reuse the missing metadata generation logic on the existing manual food creation system
- Users can be prompted with a button to generate all of the missing metadata not already filled in

GENERAL REQUIREMENTS:
- Ensure the entire system functions end-to-end.
- Prioritize working and tested code over literal adherence to this prompt.
- Ensure testing covers all use cases. Do not limit testing to reduce API costs

=== Food logger UI changes ===
Repeat your rules so that it can be ensured you are following them correctly. 
Update the food logging UI to support both PC and mobile views while maintaining existing logic, code style, and visual guidelines used in the project. 
Review the database setup scripts before accessing any data to confirm the correct schema. 
Do not rewrite existing working logic. Remove unused UI components or code that is no longer used.

MAIN SCREEN:
- Display the user's current food metadata progress for the day (calories, protein, fat, carbs).
- Get goal values from the user_goal table.
- Show a circular progress bar for calories, protein, fat, and carbs on the main view.
- When the user clicks the progress section, expand to show all other metadata except:
  tokens goal, weight goal, lean mass goal, and fat mass goal.
- The expanded metadata screen should use linear progress bars with numbers.
- Each progress bar should have a distinct color.
- Show the numeric progress and the amount remaining for each goal.

FOOD LOG LIST:
- Show all foods logged for the selected day.
- Each entry should include: name, time logged, servings, calories, protein, carbs, and food group icon.
- Add separation lines at 6am, 9am, 12pm, 3pm, 6pm, 9pm, and 12am.
- Include a day selector to view logs and goal progress for other dates.
- Display the number of foods logged for the current day.

FOOD LOGGER:
- On PC view: show the food logger panel beside the food list.
- On mobile view: show a button to open a food logging screen.
- Include a search bar to search all user foods and meals.
- Include a toggle button to show or hide public foods.
- If no search is made, show foods sorted by most frequently logged.
- Each food card should display: calories, protein, fat, carbs, and food group icon.
- Each food should have an input for servings, adjustable by up/down arrows or manual entry.
- Changing servings should automatically update the shown macros.
- Include an "Add" button for each food that logs it without closing the screen.

FOOD CREATOR:
- On PC view: show the food creator beside the food list.
- On mobile view: show a button to open a separate food creator screen.
- Allow editing all food metadata fields.
- Include options to:
  1. Make the food public.
  2. Log the food immediately after creation.
  3. Generate missing metadata using AI.

MEAL CREATION:
- Include a button to open the meal creation screen.
- Use the same list and search UI as the food logger.
- Allow the user to search and add foods to a meal.
- Allow changing the meal name.
- Include a button to log all foods after creating the meal.

AI FOOD LOGGER:
- Include a button to open the AI food logger screen.
- Include a text box for manual text input.
- Include a record button to start voice input that becomes a stop button during recording.
- The transcribed recording will show in the same text box as the manual text input.
- Add a checkbox to mark input as a meal.
- Display the last 10 foods logged with the same layout and style as the main food list.
- Display the number of AI requests made that day and the number of tokens used.

Ensure all UI changes follow the same color scheme, spacing, typography, and component styles as the existing project.
Remove any redundant UI or unused logic from previous versions.


=== Profile Improvements ===
Repeat your rules so it can be ensured you are following them completely 
Update the profile section of the application with the following improvements. Ensure all changes use the correct database schema by reviewing the setup scripts. Remove the dashboard and OpenAI menus from the application.

GENERAL LAYOUT:
- Implement both mobile and desktop versions.
- The desktop version should minimize whitespace on screen edges.
- Mobile view should retain a mobile-friendly layout.

USER PERSONAL INFORMATION:
- Display all user personal information.
- Provide options to update personal information.

GOALS:
- Display weight goal, lean mass goal, fat mass goal, and cost goal with options to update them.
- Display all macro goals (calories, protein, fat, carbs, etc.) with options to update them.
- Include a feature to generate all macro goals based on the timeframe to achieve the user’s goal weight.
  - Calculations should use standard equations considering: current weight, goal weight, height, age, activity level, and gender.
  - Provide warnings if the weight goal is extreme for the selected timeframe.
  - Include messages explaining that calculated macros may not be 100% accurate due to natural differences.

CALCULATED BODY METRICS:
- Provide calculated values based on current weight, height, age, activity level, gender, and measurements.
- Provide reference values labeled as: dirt, gravel, tin, aluminum, lead, bronze, copper, iron, quartz, gold, ruby, crystal, emerald, diamond, titanium, platinum, mithril, according to user gender, weight, height, and age.
  - The user should be provided which rank they are currently at along with what value they require to get to the next rank.
- Display the following metrics:
  - Body Mass Index (BMI)
  - Waist-to-Height Ratio
  - Waist-to-Shoulder Ratio
  - Legs-to-Height Ratio
  - Basal Metabolic Rate (BMR)
  - Total Daily Energy Expenditure (TDEE)
  - Fat Mass Percentage
  - Lean Mass Percentage
  - Fat-Free Body Mass Index (FFBMI)

HISTORICAL DATA:
- Provide total weight lost or gained.
- Provide recommended weekly weight gain or loss to achieve goals.

LOGOUT:
- Remove the logout button from the top tab.
- Add the logout button at the bottom of the profile section.

GENERAL REQUIREMENTS:
- Maintain existing visual styling, spacing, and color schemes.
- Ensure all fields are editable where specified and validate user input.
- Ensure desktop and mobile layouts adjust dynamically based on screen size.
- Remove any unused code or UI components from previous versions.

=== Workout Tracker ===

Create a Workout Tracker section in the application. Review the database setup scripts to ensure all queries and inserts use the correct schema. Maintain existing logic where implemented; do not rewrite working code. Remove any unused UI or logic.

MUSCLE PRIORITY:
- Provide a menu to adjust priority for each muscle, updating the muscle_log table.
- Show muscle groups with expandable sections to adjust individual muscles.
- Explain that priority is used for emphasizing, balancing, or improving weaker/stronger muscles.
- Base priority should be 80. All muscles should have a priority.
- Include an "Update" button at the bottom to save changes.

WORKOUT ADDER:
- Allow users to add new workouts.
- All metadata in the workouts table should be editable.
- Allow adding muscles with activation ratings via the workout_muscle table.
- Include an information tooltip explaining activation ratings:
  "Workouts can be given activation ratings that range from 0-100. Muscles prioritized by the movement should have higher ratings. Examples: Bench Press: chest-100, triceps-75, front delt-40. Squats: quads-100, hamstrings-90, glutes-95, abs-20, abductor-90, adductor-90."
- Workouts can have an icon chosen from a predefined list of emojis.
  - Store the emoji in the name field internally but do not display it to the user.

SPLIT CREATOR:
- Allow users to create splits using splits, split_days, and split_day_targets tables.
- Users can add days to a split; each day has a name and list of muscles with target activation.
- Include an information tooltip:
  "Target activation ratings outline the volume for each muscle. ~225-275 activation ≈ 3 sets. Optimal per week: 10-20 sets per muscle (~2250-5550 total activation)."
- Display total activation rating per muscle across the split.
- Calculate and show optimal activation range for each muscle. P = muscle priority. D = number of days in the split
  - Lower end: R(P,D)=90⋅(10+0.1P)⋅7/D
  - Upper end: R(P,D)=90⋅(20+0.1P)⋅7⋅D
- Highlight muscles:
  - No activation → warning.
  - Below optimal → gray.
  - Within 15% of optimal → green.
  - Above optimal → red.
- Allow naming splits and showing a menu of all user splits.
- Allow users to select an active split and assign a start date.

WORKOUT LOG:
- Determine the day of the split based on the selected split's start date.
- Show muscles worked that day and progress toward daily activation goals.
- Display the name of the split day.
- Show all workouts logged for that day with: icon, name, weight, reps, attributes.
- Include a quick-add button for workouts from the previous split day.
- Include a working timer.
- Display stats at the top: total sets, total weight lifted, total reps, total RIR, total activation rating completed.
- Include a calendar that lets different days be displayed 

WORKOUT LOGGER:
- Provide a menu for adding workouts to the current log.
- Include search with filters: text, muscle activation threshold (default 80), alphabetical.
- When logging a workout, all fields should be editable.
- Attributes selection options:
  - Dropset: weight and reps
  - Assisted: reps
  - Partial: reps
  - Pause: wait time and reps
  - Negatives: reps
  - Provide short descriptions for all attribute types.
- Autofill workout fields (weight, reps, RIR, attributes) from the most recent log if the workout was done previously.
- Include description for RIR (reps in reserve).
- Show message: "Progressive overload should be done if not in a caloric deficit."


=== UI Fixes ==
The following fixes should be made to the http://localhost:3000/workout-tracker page 
Follow all of your rules at all times
Ensure all requested changes are made
Make UI changes to the desktop version of the website not mobile
    